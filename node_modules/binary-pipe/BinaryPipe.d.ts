/// <reference types="node" />
export declare type ParserFunction<T> = (iter: IterableIterator<number>) => T;
export declare type Parser<T, kT extends string> = [kT, ParserFunction<T>];
export declare type ParserResult<T, kT extends string> = {
    [key in kT]: T;
};
export interface BinaryPipe<T> {
    pipe<A, kA extends string>(p1: Parser<A, kA>): T & ParserResult<A, kA>;
    pipe<A, kA extends string, B, kB extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>): T & ParserResult<A, kA> & ParserResult<B, kB>;
    pipe<A, kA extends string, B, kB extends string, C, kC extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>): T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC>;
    pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>): T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD>;
    pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>): T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE>;
    pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string, F, kF extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>, p6: Parser<F, kF>): T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE> & ParserResult<F, kF>;
    pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string, F, kF extends string, G, kG extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>, p6: Parser<F, kF>, p7: Parser<G, kG>): T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE> & ParserResult<F, kF> & ParserResult<G, kG>;
    pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string, F, kF extends string, G, kG extends string, H, kH extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>, p6: Parser<F, kF>, p7: Parser<G, kG>, p8: Parser<H, kH>): T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE> & ParserResult<F, kF> & ParserResult<G, kG> & ParserResult<H, kH>;
    loop(count: number): {
        pipe<A, kA extends string>(p1: Parser<A, kA>): (T & ParserResult<A, kA>)[];
        pipe<A, kA extends string, B, kB extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>): (T & ParserResult<A, kA> & ParserResult<B, kB>)[];
        pipe<A, kA extends string, B, kB extends string, C, kC extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>): (T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC>)[];
        pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>): (T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD>)[];
        pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>): (T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE>)[];
        pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string, F, kF extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>, p6: Parser<F, kF>): (T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE> & ParserResult<F, kF>)[];
        pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string, F, kF extends string, G, kG extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>, p6: Parser<F, kF>, p7: Parser<G, kG>): (T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE> & ParserResult<F, kF> & ParserResult<G, kG>)[];
        pipe<A, kA extends string, B, kB extends string, C, kC extends string, D, kD extends string, E, kE extends string, F, kF extends string, G, kG extends string, H, kH extends string>(p1: Parser<A, kA>, p2: Parser<B, kB>, p3: Parser<C, kC>, p4: Parser<D, kD>, p5: Parser<E, kE>, p6: Parser<F, kF>, p7: Parser<G, kG>, p8: Parser<H, kH>): (T & ParserResult<A, kA> & ParserResult<B, kB> & ParserResult<C, kC> & ParserResult<D, kD> & ParserResult<E, kE> & ParserResult<F, kF> & ParserResult<G, kG> & ParserResult<H, kH>)[];
    };
    finish(): Buffer;
}
/**
 * BinaryPipe pipes buffer through pipeline of functions.
 * Each function will fillup initialObject with returned object.
 *
 * @param buffer - buffer to parse
 * @param initialObject - object that should be filled-up with values
 */
export declare function BinaryPipe<T extends Record<string, any>>(buffer: Buffer, initialObject?: T): BinaryPipe<T>;
