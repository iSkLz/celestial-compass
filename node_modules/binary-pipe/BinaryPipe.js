"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bufferGenerator_1 = require("./bufferGenerator");
/**
 * BinaryPipe pipes buffer through pipeline of functions.
 * Each function will fillup initialObject with returned object.
 *
 * @param buffer - buffer to parse
 * @param initialObject - object that should be filled-up with values
 */
function BinaryPipe(buffer, initialObject = {}) {
    const generator = bufferGenerator_1.bufferGenerator(buffer);
    return {
        /**
         * Pipes buffer through given parsers.
         * It's up to parser how many bytes it takes from buffer.
         * Each parser should return new literal object, that will be merged to previous object (or initialObject) by pipe.
         *
         * @param parsers - parsers for pipeline
         */
        pipe(...parsers) {
            // Call each parser and merge returned value into one object
            return parsers.reduce((previousValue, parser) => {
                const result = parser[1](generator);
                return Object.assign({}, previousValue, { [parser[0]]: result });
            }, initialObject);
        },
        /**
         * Returns special pipe function, which iterates `count` times over buffer,
         * returning array of results.
         *
         * @param count - number of times to iterate.
         */
        loop(count) {
            // save basePipe reference to avoid returned pipe calling itself
            const basePipe = this.pipe;
            return {
                pipe(...parsers) {
                    const entries = [];
                    // Call basePipe `count` times
                    for (let i = 0; i < count; i += 1) {
                        entries.push(basePipe(...parsers));
                    }
                    return entries;
                },
            };
        },
        /**
         * Returns buffer not parsed by pipe yet.
         * Closes generator, so no piping will be available after calling `finish`.
         */
        finish() {
            const buf = [];
            // Take all bytes and close generator
            let lastResult;
            do {
                lastResult = generator.next();
                buf.push(lastResult.value);
            } while (!lastResult.done);
            return Buffer.from(buf);
        },
    };
}
exports.BinaryPipe = BinaryPipe;
//# sourceMappingURL=BinaryPipe.js.map